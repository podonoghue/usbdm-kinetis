/**
 * @file     ftm.h (180.ARM_Peripherals/Project_Headers/ftm.h)
 * @brief    Flexitimer Timer Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 *      Author: podonoghue
 */
#ifndef HEADER_FTM_H
#define HEADER_FTM_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <cmath>
#include "pin_mapping.h"

/*
 * Default port information
 */
namespace USBDM {

/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 * Enables External trigger on a channel comparison or initialisation event
 */
enum FtmExternalTrigger {
   FtmExternalTrigger_ch0   = FTM_EXTTRIG_CH0TRIG_MASK,    ///< External trigger on channel 0 event
   FtmExternalTrigger_ch1   = FTM_EXTTRIG_CH1TRIG_MASK,    ///< External trigger on channel 1 event
   FtmExternalTrigger_ch2   = FTM_EXTTRIG_CH2TRIG_MASK,    ///< External trigger on channel 2 event
   FtmExternalTrigger_ch3   = FTM_EXTTRIG_CH3TRIG_MASK,    ///< External trigger on channel 3 event
   FtmExternalTrigger_ch4   = FTM_EXTTRIG_CH4TRIG_MASK,    ///< External trigger on channel 4 event
   FtmExternalTrigger_ch5   = FTM_EXTTRIG_CH5TRIG_MASK,    ///< External trigger on channel 5 event
   FtmExternalTrigger_init  = FTM_EXTTRIG_INITTRIGEN_MASK, ///< External trigger on initialisation
   FtmExternalTrigger_all   = 0x7F,                        ///< All triggers
};

/**
 * Selects pairs of channels for some operations
 */
enum FtmChannelPair {
   FtmChannelPair_0_1 = (1<<0), ///< Channel Pair select for channels 0 and 1
   FtmChannelPair_2_3 = (1<<1), ///< Channel Pair select for channels 2 and 3
   FtmChannelPair_4_5 = (1<<2), ///< Channel Pair select for channels 4 and 5
   FtmChannelPair_6_7 = (1<<3), ///< Channel Pair select for channels 6 and 6
};

/**
 * Controls value forced to pin by forceChannelOutputs()
 */
enum FtmChannelForce {    // Enable|Value
   FtmChannelForce_Release = 0x00|(0x00<<8), ///< Release channel output
   FtmChannelForce_Low     = 0xFF|(0x00<<8), ///< Force channel output low
   FtmChannelForce_High    = 0xFF|(0xFF<<8), ///< Force channel output high
};

/**
 * Provides shared methods.
 */
class FtmBase {

private:
   FtmBase(const FtmBase&) = delete;
   FtmBase(FtmBase&&) = delete;

public:

   /** Class to static check channel exists - it does not check that it is mapped to a pin */
   template<class Info, int channel> class CheckChannel {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Non-existent function
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != INVALID_PCR);

      static_assert(Test1, "Illegal FTM channel - Check Configure.usbdm for available channels");
      static_assert(Test2, "FTM channel doesn't exist in this device/package - Check Configure.usbdm for available channels");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check channel exists and is mapped to a pin */
   template<class Info, int channel> class CheckChannelExistsAndMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[channel].gpioBit >= 0);

      static_assert(Test1, "Illegal FTM channel - Check Configure.usbdm for available inputs");
      static_assert(Test2, "FTM input is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "FTM channel doesn't exist in this device/package - Check Configure.usbdm for available input pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check channel is mapped to a pin - Ignores non-existence etc. */
   template<class Info, int channel> class CheckChannelIsMappedToPinOnly {

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != UNMAPPED_PCR);

      static_assert(Test2, "FTM channel is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

protected:
   // Constructor
   constexpr FtmBase(uint32_t baseAddress) : ftm(baseAddress) {};
   ~FtmBase() = default;

   /** Allow access owning FTM */
   const HardwarePtr<FTM_Type> ftm;

   /**
    * Limit index to permitted pin index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @tparam Inf    Associated info table
    * @param index   Index to limit
    *
    * @return Index limited to permitted range
    */
   template <class Inf>
   static inline constexpr int limitIndex(int index) {
      if (index<0) {
         return 0;
      }
      if (index>(Inf::numSignals-1)) {
         return Inf::numSignals-1;
      }
      return index;
   }

   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Get Timer input frequency.
    *
    * @param ftmClockSource Clock source
    *
    * @return Clock frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual(FtmClockSource ftmClockSource) const = 0;

public:
   /**
    * Structure for FTM channel.
    */
   struct FtmChannelRegs {
      __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
      __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
   };

/*
 *   // Member functions (mirrored)
 */
   /**
    * Stop timer counter.
    * This simply disables the counter clock source. 

    * To restart use setClockSource() or configure();
    *
    * @note This function will affect all channels of the timer.
    * @note A illegal access trap will occur if the timer has not been enabled
    */
   void stopCounter() const {
     ftm->SC = (ftm->SC&~FTM_SC_PS_MASK);
   }
   
   /**
    * Set Clock Source and Clock prescaler
    *
    * @param ftmClockSource Selects the clock source for the module
    * @param ftmPrescale    Selects the prescaler for the module
    */
   void selectClock(
         FtmClockSource ftmClockSource,
         FtmPrescale    ftmPrescale) const {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~(FTM_SC_CLKS_MASK|FTM_SC_PS_MASK))|(ftmClockSource|ftmPrescale);
   
      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;
   
      // Make sure write has completed (disabled)
      (void)(ftm->SC);
   
      // Write new value
      ftm->SC = sc;
   }

   /**
    * Set Alignment and whether interval or free-running mode
    *
    * @param ftmMode Left-aligned   (cntin...mod) or
    *        Centre-aligned (cntin...mod...cntin) or
    *        Free-running   (0...maximum_value)
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setMode(FtmMode ftmMode) const {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~(FTM_SC_TOF_MASK|FTM_SC_CPWMS_MASK))|(ftmMode);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Alignment and whether interval or free-running mode
    *
    * @param ftmMode Left-aligned   (cntin...mod) or
    *        Centre-aligned (cntin...mod...cntin) or
    *        Free-running   (0...maximum_value)
    */
   FtmMode getMode() const {
   
      return (FtmMode)(ftm->SC&~(FTM_SC_TOF_MASK|FTM_SC_CPWMS_MASK));
   }

   /**
    * Set Clock Source
    *
    * @param ftmClockSource Selects the clock source for the module
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setClockSource(FtmClockSource ftmClockSource) const {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~FTM_SC_CLKS_MASK)|(ftmClockSource);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Clock Source
    *
    * @param ftmClockSource Selects the clock source for the module
    */
   FtmClockSource getClockSource() const {
   
      return (FtmClockSource)(ftm->SC&~FTM_SC_CLKS_MASK);
   }

   /**
    * Set Clock prescaler
    *
    * @param ftmPrescale Selects the prescaler for the module
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setPrescaler(FtmPrescale ftmPrescale) const {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~FTM_SC_PS_MASK)|(ftmPrescale);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Clock prescaler
    *
    * @param ftmPrescale Selects the prescaler for the module
    */
   FtmPrescale getPrescaler() const {
   
      return (FtmPrescale)(ftm->SC&~FTM_SC_PS_MASK);
   }

   /**
    * Set Start value for counter
    * This value is write-buffered and updated by CNTIN synchronisation
    *
    * @param ticks   The timer counts from this value to ftm_mod
    *
    * @note This function will affect all channels of the timer.
    */
   void setCounterStartValue(Ticks   ticks) const {
   
      // Write new value
      ftm->CNTIN = ticks;
   }
   
   /**
    * Get Start value for counter
    *
    * @param ticks   The timer counts from this value to ftm_mod
    */
   Ticks getCounterStartValue() const {
   
      return (Ticks)ftm->CNTIN;
   }

   /**
    * Set End value for counter
    * This value is write-buffered and updated by CNTIN synchronisation
    *
    * @param ticks   The timer counts from ftm_cntin to this value
    *
    * @note This function will affect all channels of the timer.
    */
   void setCounterMaximumValue(Ticks   ticks) const {
   
      // Write new value
      ftm->MOD = ticks;
   }
   
   /**
    * Get End value for counter
    *
    * @param ticks   The timer counts from ftm_cntin to this value
    */
   Ticks getCounterMaximumValue() const {
   
      return (Ticks)ftm->MOD;
   }

   /**
    * Calculate FTM timing parameters to achieve a given period
    *
    * @param[in]    period  Period in seconds
    * @param[inout] sc      Proposed FTM.SC value (must include CLKS, CPWMS fields)
    *                       PS field is updated
    * @param[out]   mod     Calculated FTM.MOD values
    *
    * @return E_NO_ERROR   Success!!
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
    * @return E_TOO_LARGE  Requested period is too large
    */
   ErrorCode calculateTimingParameters(Seconds period, uint8_t &sc, uint16_t &mod) const {
   
      float inputClock = getInputClockFrequencyVirtual((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
      unsigned prescaleFactor=1;
      unsigned prescalerValue=0;
   
      // Check if CPWMS is set (affects period calculation)
      bool centreAligned = (sc&FTM_SC_CPWMS_MASK);
   
      constexpr uint32_t maxModValue = FTM_MOD_MOD_MASK;
   
      while (prescalerValue<=7) {
         float clock    = inputClock/prescaleFactor;
         float modValueF = period*clock;
         if (centreAligned) {
            // PeriodInTicks = 2*MOD
            modValueF = modValueF/2;
         }
         else {
            // PeriodInTicks = MOD+1
            modValueF = modValueF - 1;
         }
         unsigned modValue = round(modValueF);
         if (modValue <= maxModValue) {
            sc   = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
            mod  = modValue;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      usbdm_assert(false, "Interval is too long");
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period
    *
    * @param[in] period   Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note The counter load value (CNTIN) is cleared
    * @note The counter modulo value (MOD) is modified to obtain the requested period
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   ErrorCode setPeriod(Seconds period) const {
   
      uint16_t modValue = 0;
   
      uint8_t sc = ftm->SC;
   
      ErrorCode rc = calculateTimingParameters(period, sc, modValue);
   
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      ftm->SC = 0;
   
      // Configure for modulo operation
      ftm->MOD   = modValue;
      ftm->CNTIN = 0_ticks;
   
      // Clear counter
      ftm->CNT   = 0;
   
      // Set prescale and enable timer
      ftm->SC  = sc;
   
      return E_NO_ERROR;
   }
   
   /**
    * Set maximum interval for input-capture or output compare.
    * Input Capture and Output Compare will be able to operate over
    * at least this period without overflow.
    *
    * @param[in] interval Interval in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note FTM counter is configured for free-running mode i.e. 0-65535
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   ErrorCode setMaximumInterval(Seconds interval) const {
   
      uint16_t       modValue;
   
      uint8_t sc = ftm->SC;
   
      ErrorCode rc = calculateTimingParameters(interval, sc, modValue);
      if (rc != E_NO_ERROR) {
         return rc;
      }
   
      // Disable timer to change prescaler and period
      ftm->SC = 0;
   
      // Configure for free-running mode
      // This is the usual value for IC or OC set-up
      ftm->MOD   = 0_ticks;
      ftm->CNTIN = 0_ticks;
   
      // Clear counter
      ftm->CNT   = 0;
   
      // Set prescale and enable timer
      ftm->SC  = sc;
   
      return E_NO_ERROR;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   float getTickFrequencyAsFloat() const {
   
      // Calculate timer prescale factor
      float prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
   
      return getInputClockFrequencyVirtual((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
   }
   
   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   uint32_t getTickFrequencyAsInt() const {
   
      // Calculate timer prescale factor
      int prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
   
      return getInputClockFrequencyVirtual((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the Timer minimum resolution
    */
   Ticks convertMicrosecondsToTicks(int time) const {
   
      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      return (unsigned)rv;
   }
   
   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). 

    * @note Will set error code if calculated value is less the minimum resolution
    */
   Ticks convertSecondsToTicks(Seconds seconds) const {
   
      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = rintf((float)seconds*tickRate);
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      return (unsigned)rv;
   }
   
   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   uint32_t convertTicksToMicroseconds(Ticks timeInTicks) const {
   
      // Calculate period
      uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   
   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   uint32_t convertTicksToMilliseconds(Ticks timeInTicks) const {
   
      // Calculate period
      uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   
   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in seconds
    */
   Seconds convertTicksToSeconds(Ticks timeInTicks) const {
      return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
   }
   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   uint16_t getTime() const {
      return ftm->CNT;
   }
   
   /**
    * Reset counter to initial value
    */
   void resetTime() const {
      // Note: writing ANY value loads CNT from CNTIN
      ftm->CNT = 0;
   }
   
   /**
    * Get timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   unsigned getInterruptFlags() const {
      return ftm->STATUS;
   }
   
   /**
    * Clear selected timer event flags
    *
    * @param channelMask Mask indicating which channel flags to clear
    *                    There is one bit for each channel
    *
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   void clearSelectedInterruptFlags(uint32_t channelMask) const {
      (void)ftm->STATUS;
      ftm->STATUS = ~channelMask;
   }
   
   /**
    * Clear timer overflow event flag
    */
   void clearOverflowInterruptFlag() {
      // Clear TOI flag (w0c)
      ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
   }
   
   /**
    * Get and clear timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   unsigned getAndClearInterruptFlags() const {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = ftm->STATUS;
      ftm->STATUS = ~status;
      return status;
   }
   
   /**
    * Enables/disable the external trigger on a channel comparison or initialisation event
    *
    * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
    * @param[in] enable             Whether to enable/disable the specified trigger
    */
   void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true) const {
      if (enable) {
         ftm->EXTTRIG = ftm->EXTTRIG | ftmExternalTrigger;
      }
      else {
         ftm->EXTTRIG = ftm->EXTTRIG & ~ftmExternalTrigger;
      }
   }
   
   /**
    * Enables multiple external triggers on a channel comparison or initialisation event
    *
    * @param[in] externalTriggers Indicates the events to cause the external trigger. 

    *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
    * @param[in] enable           Whether to enable/disable the specified triggers
    */
   void enableExternalTriggers(int externalTriggers, bool enable=true) const {
      enableExternalTrigger((FtmExternalTrigger)externalTriggers, enable);
   }
   
   /**
    * Enable/disable Timer Overflow interrupts
    */
   void enableTimerOverflowInterrupts() const {
      ftm->SC = ftm->SC | FTM_SC_TOIE_MASK;
   }
   
   /**
    * Disable Timer Overflow interrupts
    */
   void disableTimerOverflowInterrupts() const {
      ftm->SC = ftm->SC & ~FTM_SC_TOIE_MASK;
   }
   
   /**
    * Enable fault interrupts
    */
   void enableFaultInterrupt() const {
      ftm->MODE = ftm->MODE | FTM_MODE_FAULTIE_MASK;
   }
   
   /**
    * Disable fault interrupts
    */
   void disableFaultInterrupt() const {
      ftm->MODE = ftm->MODE & ~FTM_MODE_FAULTIE_MASK;
   }
   
   /**
    *  Disables fault detection input
    *
    *  @tparam inputNum        Number of fault input to enable (0..3)
    */
   template<int inputNum>
   void disableFault() const {
      static_assert(inputNum<=4, "Illegal fault channel");
   
      // Enable fault on channel
      ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<inputNum);
   }
   
   /**
    *  Enables fault detection input
    *
    *  @tparam inputNum           Number of fault input to enable (0..3)
    *
    *  @param[in]  polarity       Polarity of fault input
    *  @param[in]  filterEnable   Whether to enable filtering on the fault input
    *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
    *
    *  NOTE - the filter delay is shared by all inputs
    */
public:
   template<uint8_t inputNum>
   void enableFault(
         Polarity polarity     = ActiveHigh,
         bool     filterEnable = false,
         uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1)) const {
   
   
      if (polarity) {
         // Set active high
         ftm->FLTPOL = ftm->FLTPOL & ~(1<<inputNum);
      }
      else {
         // Set active low
         ftm->FLTPOL = ftm->FLTPOL | (1<<inputNum);
      }
      if (filterEnable) {
         // Enable filter & set filter delay
         ftm->FLTCTRL = ((ftm->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
      }
      else {
         // Disable filter
         ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
      }
      // Enable fault input
      ftm->FLTCTRL = ftm->FLTCTRL | (1<<inputNum);
      // Enable fault mode (All channels, manual)
      ftm->MODE    = ftm->MODE | FTM_MODE_FAULTM(2);
   }

   /**
    * Set polarity of all channels
    *
    * @param channelMask   Bit mask 0 => active-high, 1 => active-low
    */
    void setPolarity(uint32_t channelMask) const {
      ftm->POL = channelMask;
   }
   
   /**
    * Set polarity of selected channels
    *
    * @param polarity      Polarity to set
    * @param channelMask   Bit mask indicating channels to affect
    */
   void setPolarity(Polarity polarity, uint32_t channelMask) const {
      if (polarity) {
         ftm->POL = ftm->POL & ~channelMask;
      }
      else {
         ftm->POL = ftm->POL | channelMask;
      }
   }

   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Set PWM duty cycle.
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(float dutyCycle, int channel) const {
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         ftm->CONTROLS[channel].CnV  = round((dutyCycle*ftm->MOD)/100.0f);
      }
      else {
         ftm->CONTROLS[channel].CnV  = round((dutyCycle*(ftm->MOD+1))/100.0f);
      }
   }
   
   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(int dutyCycle, int channel) const {
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         ftm->CONTROLS[channel].CnV  = (dutyCycle*ftm->MOD)/100;
      }
      else {
         ftm->CONTROLS[channel].CnV  = (dutyCycle*(ftm->MOD+1))/100;
      }
   }
   
   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   ErrorCode setHighTime(Ticks highTime, int channel) const {
   
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1_ticks)/2U;
      }
#ifdef DEBUG_BUILD
      if ((unsigned)highTime > ftm->MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      ftm->CONTROLS[channel].CnV  = (unsigned)highTime;
      return E_NO_ERROR;
   }
   
   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event in ticks i.e. value from timer event register
    */
   Ticks getEventTime(int channel) const {
      return (unsigned)(ftm->CONTROLS[channel].CnV);
   }
   
   /**
    * Set Timer event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   void setEventTime(Ticks eventTime, int channel) const {
      ftm->CONTROLS[channel].CnV = (unsigned)eventTime;
   }
   
   /**
    * Set Timer event time relative to current event time
    *
    * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   void setDeltaEventTime(Ticks offset, int channel) const {
      ftm->CONTROLS[channel].CnV = ftm->CONTROLS[channel].CnV + (unsigned)offset;
   }
   
   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   void setRelativeEventTime(Ticks offset, int channel) const {
      ftm->CONTROLS[channel].CnV = ftm->CNT + (unsigned)offset;
   }
   
   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
    */
   ErrorCode setHighTime(Seconds highTime, int channel) const {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }
   
   /**
    * Set initial state for channels outputs
    *
    * @param initialValue  Bit mask value for channels
    */
   void setOutputInitialValue(uint32_t initialValue) const {
      ftm->OUTINIT = initialValue;
   }
   
   /**
    * Set output mask for channels outputs
    *
    * The mask of a channel determines if its output responds, that is,
    * it is masked or not, when a match occurs
    * This value is write-buffered and updated by PWM synchronisation.
    *
    * @param maskValue  Bit mask value 0 => not masked, 1 => masked
    */
   void setOutputMaskValue(uint32_t maskValue) const {
      ftm->OUTMASK = maskValue;
   }
   
   /**
    * Set inverting control
    *
    * This controls when the channel (n) and (n+1) outputs are exchanged.
    * Each bit enables the inverting operation for the corresponding channels pair.
    * This value is write-buffered and updated by INVCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
    */
   void setInvertedChannelPairs(uint32_t enableMask) const {
      ftm->OUTINIT = enableMask;
   }
   
   /**
    * Force channel outputs
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
    * @param outputMask  Bit mask for values to be forced to selected channels
    */
   void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask) const {
      ftm->SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
   }
   
   /**
    * Force channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channel to be forced
    * @param value    Value to be forced on that channel
    */
   void forceChannelOutput(uint32_t channel, bool value) const {
      static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
      static constexpr unsigned FTM_SWOCTRL_CHxOCV_SHIFT  = 8;
   
      uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
      uint32_t valueMask   = 1<<(channel+FTM_SWOCTRL_CHxOCV_SHIFT);
   
      // Set control bit + insert control value
      ftm->SWOCTRL = (ftm->SWOCTRL&~valueMask) | (channelMask | (value?valueMask:0));
   }
   
   /**
    * Release forced channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channel to be released
    */
   void releaseChannelOutput(uint32_t channel) const {
      static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
   
      uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
   
      // Release control bit
      ftm->SWOCTRL = ftm->SWOCTRL & ~channelMask;
   }
   
   /**
    * Set current value of channel outputs.

    * This value is overwritten by the next channel action.
    *
    * @param channelValueMask Mask indicating desired channel outputs
    */
   void setChanelOutputs(uint32_t channelValueMask) const {
      ftm->OUTINIT = channelValueMask;
      ftm->MODE    = ftm->MODE | FTM_MODE_INIT_MASK;
   }


};

class FtmChannel : public FtmBase {

private:
   FtmChannel(const FtmChannel&) = delete;
   FtmChannel(FtmChannel&&) = delete;

protected:
   // Empty constructor
   constexpr FtmChannel(uint32_t baseAddress, FtmChannelNum channelNum) :
   FtmBase(baseAddress),
   channelRegs((uint32_t)(ftm->CONTROLS+channelNum)),
   CHANNEL(channelNum),
   CHANNEL_MASK(1<<channelNum) {
   }
   ~FtmChannel() = default;

public:
   /** Allow access to FTM channel registers */
   const HardwarePtr<FtmBase::FtmChannelRegs> channelRegs;

   /** Timer channel number */
   const FtmChannelNum CHANNEL;

   /** Mask for Timer channel */
   const uint32_t CHANNEL_MASK;

      /**
       * Configure channel.
       * No affect on shared settings of owning Timer
       *
       * @param[in] ftmChannelMode    Mode of operation for channel
       * @param[in] ftmChannelAction  Whether to enable the interrupt or DMA function on this channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
       void configure(
            FtmChannelMode    ftmChannelMode,
            FtmChannelAction  ftmChannelAction = FtmChannelAction_None) const {
   
         ftm->CONTROLS[CHANNEL].CnSC = ftmChannelMode|ftmChannelAction;
      }
   
      /**
       * Disables timer channel (sets mode to FtmChannelMode_Disabled)
       */
       void disable() const {
         setMode(FtmChannelMode_Disabled);
      }
   
      /**
       * Get channel mode.
       *
       * @return Current mode of operation for the channel
       */
       FtmChannelMode getMode() const {
         return static_cast<FtmChannelMode>(ftm->CONTROLS[CHANNEL].CnSC &
               (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
      }
   
      /**
       * Set channel mode
       *
       * @param[in] ftmChannelMode      Mode of operation for channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
       void setMode(FtmChannelMode ftmChannelMode) const {
         ftm->CONTROLS[CHANNEL].CnSC =
               (ftm->CONTROLS[CHANNEL].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|ftmChannelMode;
      }
      /**
       * Set PWM high time in ticks.
       * Assumes value is less than period
       *
       * @param[in] highTime   PWM high time in ticks
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       ErrorCode setHighTime(Ticks highTime) const {
         return FtmBase::setHighTime(highTime, CHANNEL);
      }
   
      /**
       * Set PWM high time in seconds.
       * Higher precision float version
       *
       * @param[in] highTime   PWM high time in seconds
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       ErrorCode setHighTime(Seconds highTime) const {
         return FtmBase::setHighTime(highTime, CHANNEL);
      }
      /**
       * Set PWM duty cycle.
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       void setDutyCycle(int dutyCycle) const {
         FtmBase::setDutyCycle(dutyCycle, CHANNEL);
      }
   
      /**
       * Set PWM duty cycle
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       void setDutyCycle(float dutyCycle) const {
         FtmBase::setDutyCycle(dutyCycle, CHANNEL);
      }
   
      /**
       * Set Timer event time.
       *
       * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       void setDeltaEventTime(Ticks offset) const {
         FtmBase::setDeltaEventTime(offset, CHANNEL);
      }
   
      /**
       * Set Timer event time relative to current timer count value.
       *
       * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       void setRelativeEventTime(Ticks offset) const {
         FtmBase::setRelativeEventTime(offset, CHANNEL);
      }
   
      /**
       * Set Absolute Timer event time.
       *
       * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
       void setEventTime(Ticks eventTime) const {
         FtmBase::setEventTime(eventTime, CHANNEL);
      }
   
      /**
       * Get Absolute Timer event time.
       *
       * @return Absolute time of last event in ticks i.e. value from timer event register
       */
       Ticks getEventTime() const {
         return FtmBase::getEventTime(CHANNEL);
      }
   
      /**
       * Get Timer interrupt/event flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       */
       bool getInterruptFlag() const {
         return (ftm->STATUS&CHANNEL_MASK) != 0;
      }
   
      /**
       * Get and Clear Timer channel interrupt flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       *
       * @note Only flags captured in the return value are cleared
       */
       bool getAndClearInterruptFlag() const {
         // Note - requires read and write zero to clear flags
         // so only flags captured in status are cleared
         bool status = (ftm->STATUS&CHANNEL_MASK) != 0;
         ftm->STATUS = ~CHANNEL_MASK;
         return status;
      }
   
      /**
       * Clear interrupt flag on channel.
       */
       void clearInterruptFlag() const {
         // Note - requires read and write zero to clear flag
         ftm->CONTROLS[CHANNEL].CnSC = ftm->CONTROLS[CHANNEL].CnSC & ~FTM_CnSC_CHF_MASK;
      }
   
      /**
       * Force channel output.
       *
       * This enables software control of channel output and
       * defines the value forced to the channel output.
       * This value is write-buffered and updated by SWOCTRL synchronisation.
       *
       * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
       */
       void forceChannelOutput(FtmChannelForce ftmChannelForce) const {
         static const uint32_t MASK = ((1<<CHANNEL)|(1<<(CHANNEL+8)));
         ftm->SWOCTRL = ((ftm->SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      }

      /**
       * Set polarity of channels.
       *
       * @param polarity Polarity to set
       */
       void setPolarity(Polarity polarity) const {
         FtmBase::setPolarity(polarity, CHANNEL_MASK);
      }


};

/**
 * Base class representing a FTM.
 *
 *
 * @tparam Info  Class describing FTM hardware instance
 */
template<class Info>
class FtmBase_T : public FtmBase, public Info  {

private:
   /**
    * This class is not intended to be instantiated
    */
   FtmBase_T(const FtmBase_T&) = delete;
   FtmBase_T(FtmBase_T&&) = delete;

   typedef typename Info::ChannelCallbackFunction ChannelCallbackFunction;

public:

   // Empty constructor
   constexpr FtmBase_T() : FtmBase(Info::baseAddress) {}
   virtual ~FtmBase_T() = default;

   /** Maximum counter value in ticks */
   static constexpr Ticks MaximumPeriodInTicks = FTM_MOD_MOD_MASK;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<FTM_Type> ftm = Info::baseAddress;

   /** @return Base address of FTM hardware as uint32_t */
   static constexpr uint32_t ftmBase() { return Info::baseAddress; }
   /** @return Base address of FTM.SC register as uint32_t */
   static constexpr uint32_t ftmSC() { return ftmBase() + offsetof(FTM_Type, SC); }
   /** @return Base address of FTM.CNT register as uint32_t */
   static constexpr uint32_t ftmCNT() { return ftmBase() + offsetof(FTM_Type, CNT); }
   /** @return Base address of FTM.MOD register as uint32_t */
   static constexpr uint32_t ftmMOD() { return ftmBase() + offsetof(FTM_Type, MOD); }
   /** @return Base address of FTM.CONTROL[n] struct as uint32_t */
   static constexpr uint32_t ftmCONTROL(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS) + index*sizeof(FTM_Type::CONTROLS[0]); }
   /** @return Base address of FTM.CONTROL[n].CnSC struct as uint32_t */
   static constexpr uint32_t ftmCnSC(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS) + index*sizeof(FTM_Type::CONTROLS[0])+0; }
   /** @return Base address of FTM.CONTROL[n].CnV struct as uint32_t */
   static constexpr uint32_t ftmCnV(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS) + index*sizeof(FTM_Type::CONTROLS[0])+sizeof(uint32_t); }

private:
   /** Number of channels mapped to a channel event vector */
   static constexpr unsigned ChannelVectorRatio = Info::NumChannels/Info::NumChannelVectors;

protected:
   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual(FtmClockSource ftmClockSource) const override {
      return Info::getInputClockFrequency(ftmClockSource);
   }

public:
   /**
    * Fault IRQ handler (if individually available)
    */
   static void faultIrqHandler() {
      ftm->FMS = ftm->FMS & ~FTM_FMS_FAULTF_MASK;
      Info::callback();
   }

   /**
    * Overflow IRQ handler (if individually available)
    */
   static void overflowIrqHandler() {
      // Clear TOI flag
      ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
      Info::callback();
   }

   /**
    * Common IRQ handler
    */
   static void irqHandler() {
      if ((ftm->MODE&FTM_MODE_FAULTIE_MASK) && (ftm->FMS&FTM_FMS_FAULTF_MASK)) {
         ftm->FMS = ftm->FMS & ~FTM_FMS_FAULTF_MASK;
         Info::callback();
      }
      else if ((ftm->SC&(FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) == (FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) {
         // Clear TOI flag
         ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
         Info::callback();
      }
      else {
         // Get status for channels
         uint32_t status = ftm->STATUS;
         if (status) {
            if constexpr (Info::IndividualCallbacks) {
               do {
                  auto channelNum = __builtin_ffs(status);
                  if (channelNum == 0) {
                     break;
                  }
                  channelNum--;
                  uint32_t flag = (1<<channelNum);

                  // Clear flag for channel event being handled
                  status &= ~flag;

                  // Call individual handler
                  Info::channelCallbacks[channelNum](flag);
               } while(true);
            }
            else {
               // Call shared handler
               Info::channelCallbacks[0](status);
            }
            // Clear flags for channel events being handled (w0c register if read first)
            ftm->STATUS = ~status;
         }
      }
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match ChannelCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ftm0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Ftm0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint8_t), T &object>
   static ChannelCallbackFunction wrapCallback() {
      static ChannelCallbackFunction fn = [](uint8_t status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match ChannelCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ftm0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Ftm0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint8_t)>
   static ChannelCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static ChannelCallbackFunction fn = [](uint8_t status) {
         (obj.*callback)(status);
      };
      return fn;
   }

public:
// Template _mapPinsOption.xml

   /**
    * Configures all mapped pins associated with FTM
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable) {
         Info::initPCRs();
      }
   }

   /**
    * Disabled all mapped pins associated with FTM
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable) {
         Info::clearPCRs();
      }
   }

   /**
    * Basic enable of FTM
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      Info::enableClock();
      configureAllPins();
   }

   /**
    * Disables the clock to FTM and all mapped pins
    */
   static void disable() {
      disableNvicInterrupts();
      ftm->SC = FTM_SC_CLKS(0);
      disableAllPins();
      Info::disableClock();
   }
// End Template _mapPinsOption.xml

   /**
    * Configure FTM from values specified in init
   
    * @param init Class containing initialisation values
    */
   static ErrorCode configure(const typename Info::Init &init) {
   
      // Enable peripheral clock and map pins
      enable();
   
      if constexpr (Info::irqHandlerInstalled) {
         Info::setCallbacks(init);
      }
   
      uint8_t  sc    = init.sc;
      uint16_t cntin = init.cntin;
      uint16_t mod   = init.mod;
   
      if (init.modperiod != 0) {
   
         // Calculate sc.ps, mod (assumes cntin=0)
         ErrorCode rc = calculateTimingParameters(init.modperiod, sc, mod);
         if (rc != E_NO_ERROR) {
            return rc;
         }
         // Configure for modulo operation
         cntin = 0;
      }
      if (init.sc&FtmMode_FreeRunning) {
         // Make free-running
         cntin = 0;
         mod   = FTM_MOD_MOD_MASK;
      }
      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC  = 0;
   
      // Start value for counter
      ftm->CNTIN = cntin;
   
      // End value for counter
      ftm->MOD = mod;
   
      // Restart counter
      ftm->CNT = 0;
   
      // Configure timer
      ftm->SC  = sc;
   
      return E_NO_ERROR;
   }


   /**
    * Configure Channel from values specified in channelInit
   
    * @param channelInit Class containing initialisation values
    */
   static ErrorCode configureChannel(const typename Info::ChannelInit &channelInit) {
   
      // Enable peripheral clock
      Info::enableClock();
   
      if constexpr (Info::irqHandlerInstalled && Info::IndividualCallbacks) {
         Info::setChannelCallback(channelInit);
      }
   
      // Configure timer combine mode
      if ((channelInit.channel&0b1) == 0) {
         // Even channel value controls paired channels n,n+1
         const unsigned offset = 4*channelInit.channel;
         const uint32_t mask = 0xFF<<offset;
         ftm->COMBINE = (ftm->COMBINE & ~mask) | (((channelInit.cnsc>>8)<<offset)&mask);
      }
      // Configure timer channel
      ftm->CONTROLS[channelInit.channel].CnSC = channelInit.cnsc;
      ftm->CONTROLS[channelInit.channel].CnV  = channelInit.cnv;
   
      return E_NO_ERROR;
   }


/*
 *   // Static functions (mirrored)
 */
   /**
    * Enables clock to peripheral and configures all pins.
    * Configures main operating settings for timer.
    *
    * @param ftmMode        Left-aligned   (cntin...mod) or
    *        Centre-aligned (cntin...mod...cntin) or
    *        Free-running   (0...maximum_value)
    * @param ftmClockSource Selects the clock source for the module
    * @param ftmPrescale    Selects the prescaler for the module
    */
   static void configure(
         FtmMode        ftmMode,
         FtmClockSource ftmClockSource,
         FtmPrescale    ftmPrescale    = FtmPrescale_DivBy1) {
   
      // Enable clock to peripheral
      enable();
   
      // Disable timer to change settings
      ftm->SC=0;
   
      // Make sure write has completed (disabled)
      (void)(ftm->SC);
   
      // Write new value
      ftm->SC = ftmMode|ftmClockSource|ftmPrescale;
   }

   /**
    * Stop timer counter.
    * This simply disables the counter clock source. 

    * To restart use setClockSource() or configure();
    *
    * @note This function will affect all channels of the timer.
    * @note A illegal access trap will occur if the timer has not been enabled
    */
   static void stopCounter() {
     ftm->SC = (ftm->SC&~FTM_SC_PS_MASK);
   }
   
   /**
    * Set Clock Source and Clock prescaler
    *
    * @param ftmClockSource Selects the clock source for the module
    * @param ftmPrescale    Selects the prescaler for the module
    */
   static void selectClock(
         FtmClockSource ftmClockSource,
         FtmPrescale    ftmPrescale) {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~(FTM_SC_CLKS_MASK|FTM_SC_PS_MASK))|(ftmClockSource|ftmPrescale);
   
      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;
   
      // Make sure write has completed (disabled)
      (void)(ftm->SC);
   
      // Write new value
      ftm->SC = sc;
   }

   /**
    * Set Alignment and whether interval or free-running mode
    *
    * @param ftmMode Left-aligned   (cntin...mod) or
    *        Centre-aligned (cntin...mod...cntin) or
    *        Free-running   (0...maximum_value)
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setMode(FtmMode ftmMode) {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~(FTM_SC_TOF_MASK|FTM_SC_CPWMS_MASK))|(ftmMode);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Alignment and whether interval or free-running mode
    *
    * @param ftmMode Left-aligned   (cntin...mod) or
    *        Centre-aligned (cntin...mod...cntin) or
    *        Free-running   (0...maximum_value)
    */
   static FtmMode getMode() {
   
      return (FtmMode)(ftm->SC&~(FTM_SC_TOF_MASK|FTM_SC_CPWMS_MASK));
   }

   /**
    * Set Clock Source
    *
    * @param ftmClockSource Selects the clock source for the module
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setClockSource(FtmClockSource ftmClockSource) {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~FTM_SC_CLKS_MASK)|(ftmClockSource);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Clock Source
    *
    * @param ftmClockSource Selects the clock source for the module
    */
   static FtmClockSource getClockSource() {
   
      return (FtmClockSource)(ftm->SC&~FTM_SC_CLKS_MASK);
   }

   /**
    * Set Clock prescaler
    *
    * @param ftmPrescale Selects the prescaler for the module
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setPrescaler(FtmPrescale ftmPrescale) {
   
      // Calculate new SC value
      uint32_t sc = (ftm->SC&~FTM_SC_PS_MASK)|(ftmPrescale);

      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC=0;

      // Make sure write has completed (disabled)
      (void)(ftm->SC);

      // Write new value
      ftm->SC = sc;
   }
   
   /**
    * Get Clock prescaler
    *
    * @param ftmPrescale Selects the prescaler for the module
    */
   static FtmPrescale getPrescaler() {
   
      return (FtmPrescale)(ftm->SC&~FTM_SC_PS_MASK);
   }

   /**
    * Set Start value for counter
    * This value is write-buffered and updated by CNTIN synchronisation
    *
    * @param ticks   The timer counts from this value to ftm_mod
    *
    * @note This function will affect all channels of the timer.
    */
   static void setCounterStartValue(Ticks   ticks) {
   
      // Write new value
      ftm->CNTIN = ticks;
   }
   
   /**
    * Get Start value for counter
    *
    * @param ticks   The timer counts from this value to ftm_mod
    */
   static Ticks getCounterStartValue() {
   
      return (Ticks)ftm->CNTIN;
   }

   /**
    * Set End value for counter
    * This value is write-buffered and updated by CNTIN synchronisation
    *
    * @param ticks   The timer counts from ftm_cntin to this value
    *
    * @note This function will affect all channels of the timer.
    */
   static void setCounterMaximumValue(Ticks   ticks) {
   
      // Write new value
      ftm->MOD = ticks;
   }
   
   /**
    * Get End value for counter
    *
    * @param ticks   The timer counts from ftm_cntin to this value
    */
   static Ticks getCounterMaximumValue() {
   
      return (Ticks)ftm->MOD;
   }

   /**
    * Calculate FTM timing parameters to achieve a given period
    *
    * @param[in]    period  Period in seconds
    * @param[inout] sc      Proposed FTM.SC value (must include CLKS, CPWMS fields)
    *                       PS field is updated
    * @param[out]   mod     Calculated FTM.MOD values
    *
    * @return E_NO_ERROR   Success!!
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
    * @return E_TOO_LARGE  Requested period is too large
    */
   static ErrorCode calculateTimingParameters(Seconds period, uint8_t &sc, uint16_t &mod) {
   
      float inputClock = Info::getInputClockFrequency((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
      unsigned prescaleFactor=1;
      unsigned prescalerValue=0;
   
      // Check if CPWMS is set (affects period calculation)
      bool centreAligned = (sc&FTM_SC_CPWMS_MASK);
   
      constexpr uint32_t maxModValue = FTM_MOD_MOD_MASK;
   
      while (prescalerValue<=7) {
         float clock    = inputClock/prescaleFactor;
         float modValueF = period*clock;
         if (centreAligned) {
            // PeriodInTicks = 2*MOD
            modValueF = modValueF/2;
         }
         else {
            // PeriodInTicks = MOD+1
            modValueF = modValueF - 1;
         }
         unsigned modValue = round(modValueF);
         if (modValue < Info::minimumResolution) {
            usbdm_assert(false, "Interval is too short");
            // Too short a period for minimum resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (modValue <= maxModValue) {
            sc   = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
            mod  = modValue;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      usbdm_assert(false, "Interval is too long");
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period
    *
    * @param[in] period   Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note The counter load value (CNTIN) is cleared
    * @note The counter modulo value (MOD) is modified to obtain the requested period
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static ErrorCode setPeriod(Seconds period) {
   
      uint16_t modValue = 0;
   
      uint8_t sc = ftm->SC;
   
      ErrorCode rc = calculateTimingParameters(period, sc, modValue);
   
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      ftm->SC = 0;
   
      // Configure for modulo operation
      ftm->MOD   = modValue;
      ftm->CNTIN = 0_ticks;
   
      // Clear counter
      ftm->CNT   = 0;
   
      // Set prescale and enable timer
      ftm->SC  = sc;
   
      return E_NO_ERROR;
   }
   
   /**
    * Set maximum interval for input-capture or output compare.
    * Input Capture and Output Compare will be able to operate over
    * at least this period without overflow.
    *
    * @param[in] interval Interval in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note FTM counter is configured for free-running mode i.e. 0-65535
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static ErrorCode setMaximumInterval(Seconds interval) {
   
      uint16_t       modValue;
   
      uint8_t sc = ftm->SC;
   
      ErrorCode rc = calculateTimingParameters(interval, sc, modValue);
      if (rc != E_NO_ERROR) {
         return rc;
      }
   
      // Disable timer to change prescaler and period
      ftm->SC = 0;
   
      // Configure for free-running mode
      // This is the usual value for IC or OC set-up
      ftm->MOD   = 0_ticks;
      ftm->CNTIN = 0_ticks;
   
      // Clear counter
      ftm->CNT   = 0;
   
      // Set prescale and enable timer
      ftm->SC  = sc;
   
      return E_NO_ERROR;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   static float getTickFrequencyAsFloat() {
   
      // Calculate timer prescale factor
      float prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
   
      return Info::getInputClockFrequency((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
   }
   
   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getTickFrequencyAsInt() {
   
      // Calculate timer prescale factor
      int prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
   
      return Info::getInputClockFrequency((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the Timer minimum resolution
    */
   static Ticks convertMicrosecondsToTicks(int time) {
   
      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return (unsigned)rv;
   }
   
   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). 

    * @note Will set error code if calculated value is less the minimum resolution
    */
   static Ticks convertSecondsToTicks(Seconds seconds) {
   
      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = rintf((float)seconds*tickRate);
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return (unsigned)rv;
   }
   
   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMicroseconds(Ticks timeInTicks) {
   
      // Calculate period
      uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   
   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMilliseconds(Ticks timeInTicks) {
   
      // Calculate period
      uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   
   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in seconds
    */
   static Seconds convertTicksToSeconds(Ticks timeInTicks) {
      return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
   }
   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   static uint16_t getTime() {
      return ftm->CNT;
   }
   
   /**
    * Reset counter to initial value
    */
   static void resetTime() {
      // Note: writing ANY value loads CNT from CNTIN
      ftm->CNT = 0;
   }
   
   /**
    * Get timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   static unsigned getInterruptFlags() {
      return ftm->STATUS;
   }
   
   /**
    * Clear selected timer event flags
    *
    * @param channelMask Mask indicating which channel flags to clear
    *                    There is one bit for each channel
    *
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   static void clearSelectedInterruptFlags(uint32_t channelMask) {
      (void)ftm->STATUS;
      ftm->STATUS = ~channelMask;
   }
   
   /**
    * Clear timer overflow event flag
    */
   static void clearOverflowInterruptFlag() {
      // Clear TOI flag (w0c)
      ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
   }
   
   /**
    * Get and clear timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   static unsigned getAndClearInterruptFlags() {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = ftm->STATUS;
      ftm->STATUS = ~status;
      return status;
   }
   
   /**
    * Enables/disable the external trigger on a channel comparison or initialisation event
    *
    * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
    * @param[in] enable             Whether to enable/disable the specified trigger
    */
   static void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true) {
      if (enable) {
         ftm->EXTTRIG = ftm->EXTTRIG | ftmExternalTrigger;
      }
      else {
         ftm->EXTTRIG = ftm->EXTTRIG & ~ftmExternalTrigger;
      }
   }
   
   /**
    * Enables multiple external triggers on a channel comparison or initialisation event
    *
    * @param[in] externalTriggers Indicates the events to cause the external trigger. 

    *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
    * @param[in] enable           Whether to enable/disable the specified triggers
    */
   static void enableExternalTriggers(int externalTriggers, bool enable=true) {
      enableExternalTrigger((FtmExternalTrigger)externalTriggers, enable);
   }
   
   /**
    * Enable/disable Timer Overflow interrupts
    */
   static void enableTimerOverflowInterrupts() {
      ftm->SC = ftm->SC | FTM_SC_TOIE_MASK;
   }
   
   /**
    * Disable Timer Overflow interrupts
    */
   static void disableTimerOverflowInterrupts() {
      ftm->SC = ftm->SC & ~FTM_SC_TOIE_MASK;
   }
   
   /**
    * Enable fault interrupts
    */
   static void enableFaultInterrupt() {
      ftm->MODE = ftm->MODE | FTM_MODE_FAULTIE_MASK;
   }
   
   /**
    * Disable fault interrupts
    */
   static void disableFaultInterrupt() {
      ftm->MODE = ftm->MODE & ~FTM_MODE_FAULTIE_MASK;
   }
   
   /**
    *  Disables fault detection input
    *
    *  @tparam inputNum        Number of fault input to enable (0..3)
    */
   template<int inputNum>
   static void disableFault() {
      static_assert(inputNum<=4, "Illegal fault channel");
   
      // Enable fault on channel
      ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<inputNum);
   }
   
   /**
    *  Enables fault detection input
    *
    *  @tparam inputNum           Number of fault input to enable (0..3)
    *
    *  @param[in]  polarity       Polarity of fault input
    *  @param[in]  filterEnable   Whether to enable filtering on the fault input
    *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
    *
    *  NOTE - the filter delay is shared by all inputs
    */
public:
   template<uint8_t inputNum>
   static void enableFault(
         Polarity polarity     = ActiveHigh,
         bool     filterEnable = false,
         uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1)) {
   
#ifdef DEBUG_BUILD
      static_assert((inputNum<Info::InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit == UNMAPPED_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit == INVALID_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit >= 0), "Pcr_T: Illegal signal used for fault");
#endif
   
      PcrTable_T<typename Info::InfoFAULT, inputNum>::setPCR();
   
      if (polarity) {
         // Set active high
         ftm->FLTPOL = ftm->FLTPOL & ~(1<<inputNum);
      }
      else {
         // Set active low
         ftm->FLTPOL = ftm->FLTPOL | (1<<inputNum);
      }
      if (filterEnable) {
         // Enable filter & set filter delay
         ftm->FLTCTRL = ((ftm->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
      }
      else {
         // Disable filter
         ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
      }
      // Enable fault input
      ftm->FLTCTRL = ftm->FLTCTRL | (1<<inputNum);
      // Enable fault mode (All channels, manual)
      ftm->MODE    = ftm->MODE | FTM_MODE_FAULTM(2);
   }

   /**
    * Set polarity of all channels
    *
    * @param channelMask   Bit mask 0 => active-high, 1 => active-low
    */
   static  void setPolarity(uint32_t channelMask) {
      ftm->POL = channelMask;
   }
   
   /**
    * Set polarity of selected channels
    *
    * @param polarity      Polarity to set
    * @param channelMask   Bit mask indicating channels to affect
    */
   static void setPolarity(Polarity polarity, uint32_t channelMask) {
      if (polarity) {
         ftm->POL = ftm->POL & ~channelMask;
      }
      else {
         ftm->POL = ftm->POL | channelMask;
      }
   }

   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Set PWM duty cycle.
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(float dutyCycle, int channel) {
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         ftm->CONTROLS[channel].CnV  = round((dutyCycle*ftm->MOD)/100.0f);
      }
      else {
         ftm->CONTROLS[channel].CnV  = round((dutyCycle*(ftm->MOD+1))/100.0f);
      }
   }
   
   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(int dutyCycle, int channel) {
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         ftm->CONTROLS[channel].CnV  = (dutyCycle*ftm->MOD)/100;
      }
      else {
         ftm->CONTROLS[channel].CnV  = (dutyCycle*(ftm->MOD+1))/100;
      }
   }
   
   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static ErrorCode setHighTime(Ticks highTime, int channel) {
   
      if (ftm->SC&FTM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1_ticks)/2U;
      }
#ifdef DEBUG_BUILD
      if ((unsigned)highTime > ftm->MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      ftm->CONTROLS[channel].CnV  = (unsigned)highTime;
      return E_NO_ERROR;
   }
   
   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event in ticks i.e. value from timer event register
    */
   static Ticks getEventTime(int channel) {
      return (unsigned)(ftm->CONTROLS[channel].CnV);
   }
   
   /**
    * Set Timer event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   static void setEventTime(Ticks eventTime, int channel) {
      ftm->CONTROLS[channel].CnV = (unsigned)eventTime;
   }
   
   /**
    * Set Timer event time relative to current event time
    *
    * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static void setDeltaEventTime(Ticks offset, int channel) {
      ftm->CONTROLS[channel].CnV = ftm->CONTROLS[channel].CnV + (unsigned)offset;
   }
   
   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static void setRelativeEventTime(Ticks offset, int channel) {
      ftm->CONTROLS[channel].CnV = ftm->CNT + (unsigned)offset;
   }
   
   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
    */
   static ErrorCode setHighTime(Seconds highTime, int channel) {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }
   
   /**
    * Set initial state for channels outputs
    *
    * @param initialValue  Bit mask value for channels
    */
   static void setOutputInitialValue(uint32_t initialValue) {
      ftm->OUTINIT = initialValue;
   }
   
   /**
    * Set output mask for channels outputs
    *
    * The mask of a channel determines if its output responds, that is,
    * it is masked or not, when a match occurs
    * This value is write-buffered and updated by PWM synchronisation.
    *
    * @param maskValue  Bit mask value 0 => not masked, 1 => masked
    */
   static void setOutputMaskValue(uint32_t maskValue) {
      ftm->OUTMASK = maskValue;
   }
   
   /**
    * Set inverting control
    *
    * This controls when the channel (n) and (n+1) outputs are exchanged.
    * Each bit enables the inverting operation for the corresponding channels pair.
    * This value is write-buffered and updated by INVCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
    */
   static void setInvertedChannelPairs(uint32_t enableMask) {
      ftm->OUTINIT = enableMask;
   }
   
   /**
    * Force channel outputs
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
    * @param outputMask  Bit mask for values to be forced to selected channels
    */
   static void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask) {
      ftm->SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
   }
   
   /**
    * Force channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channel to be forced
    * @param value    Value to be forced on that channel
    */
   static void forceChannelOutput(uint32_t channel, bool value) {
      static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
      static constexpr unsigned FTM_SWOCTRL_CHxOCV_SHIFT  = 8;
   
      uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
      uint32_t valueMask   = 1<<(channel+FTM_SWOCTRL_CHxOCV_SHIFT);
   
      // Set control bit + insert control value
      ftm->SWOCTRL = (ftm->SWOCTRL&~valueMask) | (channelMask | (value?valueMask:0));
   }
   
   /**
    * Release forced channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channel to be released
    */
   static void releaseChannelOutput(uint32_t channel) {
      static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
   
      uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
   
      // Release control bit
      ftm->SWOCTRL = ftm->SWOCTRL & ~channelMask;
   }
   
   /**
    * Set current value of channel outputs.

    * This value is overwritten by the next channel action.
    *
    * @param channelValueMask Mask indicating desired channel outputs
    */
   static void setChanelOutputs(uint32_t channelValueMask) {
      ftm->OUTINIT = channelValueMask;
      ftm->MODE    = ftm->MODE | FTM_MODE_INIT_MASK;
   }


   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

public:
   /**
    * Template class representing a timer channel
    *
    * Example
    * @code
    * // Instantiate the timer and channel being used (for FTM0 & channel 6)
    * using Tmr      = USBDM::Ftm0;
    * using Tmr0_ch6 = Tmr::Channel<6>;
    *
    * // Enable and initialise timer with initial alignment
    * Tmr::configure(FtmAlignment_LeftAlign);
    *
    * // Change timer period (in ticks) (affects ALL channels of timer)
    * Tmr::setPeriod(500);
    *
    * // Configure channel as PWM
    * Tmr0_ch6::configure(FtmChannelMode_PwmHighTruePulses);
    *
    * // Change duty cycle (in percent)
    * Tmr0_ch6.setDutyCycle(45);
    * @endcode
    *
    * @tparam channel FTM timer channel
    */
   template <int channel>
   class Channel : public PcrTable_T<Info, limitIndex<Info>(channel)>, public FtmChannel {

   private:
      FtmBase::CheckChannel<Info, channel> check;

   private:
      /**
       * This class is not intended to be instantiated
       */
      Channel(const Channel&) = delete;
      Channel(Channel&&) = delete;

   public:
      typedef typename Info::ChannelInit ChannelInit;

      constexpr Channel() : FtmChannel(Info::baseAddress, channel) {}
      virtual ~Channel() = default;

   protected:
      /**
       * Get frequency of timer tick
       *
       * @return Timer frequency in Hz
       */
      virtual float getInputClockFrequencyVirtual(FtmClockSource ftmClockSource) const override {
         return Info::getInputClockFrequency(ftmClockSource);
      }

   public:
      // GPIO associated with this channel
      template<Polarity polarity>
      using Gpio = GpioTable_T<Info, limitIndex<Info>(channel), polarity>; // Inactive is high

      /** Allow access to PCR of associated pin */
      using Pcr = PcrTable_T<Info, limitIndex<Info>(channel)>;

      /** Allow access owning FTM */
      using OwningFtm = FtmBase_T<Info>;

      /** Allow access to FTM hardware */
      static constexpr HardwarePtr<FTM_Type> ftm = Info::baseAddress;

      /** @return Base address of FTM.CONTROL struct as uint32_t */
      static constexpr uint32_t ftmCONTROL() { return ftmBase() + offsetof(FTM_Type, CONTROLS[channel]); }

      /** @return Address of FTM.CONTROL.CnSC as uint32_t */
      static constexpr uint32_t ftmCnSC() { return ftmCONTROL()+0; }

      /** @return Address of FTM.CONTROL.CnV as uint32_t */
      static constexpr uint32_t ftmCnV() { return ftmCONTROL()+sizeof(uint32_t); }

      /**
       * Structure for FTM channel.
       */
      struct FtmChannelRegs {
         __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
         __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
      };

      /**
       * Allows access to FTM channel registers.
       *
       * @return Reference to the FTM channel registers
       */
      static __attribute__((always_inline)) volatile FtmChannelRegs &channelRegs() {
         return *reinterpret_cast<FtmChannelRegs *>(&OwningFtm::ftm->CONTROLS[CHANNEL]);
      }

      /** Timer channel number */
      static constexpr FtmChannelNum CHANNEL = (FtmChannelNum) channel;

      /** Mask for Timer channel */
      static constexpr uint32_t CHANNEL_MASK = 1<<channel;

      /**
       * Configure channel and sets mode.
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void defaultConfigure() {
         OwningFtm::configureChannel(OwningFtm::DefaultChannelInitValues[channel]);
      }

      /**
       * Configure channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void configure(const ChannelInit &channelInit) {
         OwningFtm::configureChannel(channelInit);
      }
      
      /**
       * Configure channel.
       * No affect on shared settings of owning Timer
       *
       * @param[in] ftmChannelMode    Mode of operation for channel
       * @param[in] ftmChannelAction  Whether to enable the interrupt or DMA function on this channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static  void configure(
            FtmChannelMode    ftmChannelMode,
            FtmChannelAction  ftmChannelAction = FtmChannelAction_None) {
   
         ftm->CONTROLS[channel].CnSC = ftmChannelMode|ftmChannelAction;
      }
   
      /**
       * Disables timer channel (sets mode to FtmChannelMode_Disabled)
       */
      static  void disable() {
         setMode(FtmChannelMode_Disabled);
      }
   
      /**
       * Get channel mode.
       *
       * @return Current mode of operation for the channel
       */
      static  FtmChannelMode getMode() {
         return static_cast<FtmChannelMode>(ftm->CONTROLS[channel].CnSC &
               (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
      }
   
      /**
       * Set channel mode
       *
       * @param[in] ftmChannelMode      Mode of operation for channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static  void setMode(FtmChannelMode ftmChannelMode) {
         ftm->CONTROLS[channel].CnSC =
               (ftm->CONTROLS[channel].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|ftmChannelMode;
      }
      /**
       * Set PWM high time in ticks.
       * Assumes value is less than period
       *
       * @param[in] highTime   PWM high time in ticks
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  ErrorCode setHighTime(Ticks highTime) {
         return OwningFtm::setHighTime(highTime, channel);
      }
   
      /**
       * Set PWM high time in seconds.
       * Higher precision float version
       *
       * @param[in] highTime   PWM high time in seconds
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  ErrorCode setHighTime(Seconds highTime) {
         return OwningFtm::setHighTime(highTime, channel);
      }
      /**
       * Set PWM duty cycle.
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  void setDutyCycle(int dutyCycle) {
         OwningFtm::setDutyCycle(dutyCycle, channel);
      }
   
      /**
       * Set PWM duty cycle
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  void setDutyCycle(float dutyCycle) {
         OwningFtm::setDutyCycle(dutyCycle, channel);
      }
   
      /**
       * Set Timer event time.
       *
       * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  void setDeltaEventTime(Ticks offset) {
         OwningFtm::setDeltaEventTime(offset, channel);
      }
   
      /**
       * Set Timer event time relative to current timer count value.
       *
       * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  void setRelativeEventTime(Ticks offset) {
         OwningFtm::setRelativeEventTime(offset, channel);
      }
   
      /**
       * Set Absolute Timer event time.
       *
       * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static  void setEventTime(Ticks eventTime) {
         OwningFtm::setEventTime(eventTime, channel);
      }
   
      /**
       * Get Absolute Timer event time.
       *
       * @return Absolute time of last event in ticks i.e. value from timer event register
       */
      static  Ticks getEventTime() {
         return OwningFtm::getEventTime(channel);
      }
   
      /**
       * Get Timer interrupt/event flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       */
      static  bool getInterruptFlag() {
         return (ftm->STATUS&CHANNEL_MASK) != 0;
      }
   
      /**
       * Get and Clear Timer channel interrupt flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       *
       * @note Only flags captured in the return value are cleared
       */
      static  bool getAndClearInterruptFlag() {
         // Note - requires read and write zero to clear flags
         // so only flags captured in status are cleared
         bool status = (ftm->STATUS&CHANNEL_MASK) != 0;
         ftm->STATUS = ~CHANNEL_MASK;
         return status;
      }
   
      /**
       * Clear interrupt flag on channel.
       */
      static  void clearInterruptFlag() {
         // Note - requires read and write zero to clear flag
         ftm->CONTROLS[CHANNEL].CnSC = ftm->CONTROLS[CHANNEL].CnSC & ~FTM_CnSC_CHF_MASK;
      }
   
      /**
       * Force channel output.
       *
       * This enables software control of channel output and
       * defines the value forced to the channel output.
       * This value is write-buffered and updated by SWOCTRL synchronisation.
       *
       * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
       */
      static  void forceChannelOutput(FtmChannelForce ftmChannelForce) {
         static const uint32_t MASK = ((1<<channel)|(1<<(channel+8)));
         ftm->SWOCTRL = ((ftm->SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      }

      /**
       * Set polarity of channels.
       *
       * @param polarity Polarity to set
       */
      static  void setPolarity(Polarity polarity) {
         OwningFtm::setPolarity(polarity, CHANNEL_MASK);
      }


   /**
    * Set channel event callback function
    *
    * @param[in] callback Callback function to execute on channel event interrupt.
    *                     Use nullptr to remove callback.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note Channel callbacks may be shared by multiple channels of the timer.\n
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      if constexpr (Info::IndividualCallbacks) {
         return OwningFtm::setChannelCallback(channel, callback);
      }
      else {
         return OwningFtm::setChannelCallback(callback);
      }
   }

   /*******************************
    *  PIN Functions
    *******************************/
   /**
    * Set callback for Pin IRQ.
    *
    * @param[in] callback The function to call on Pin interrupt.
    *                     nullptr to indicate none
    *
    * @note There is a single callback function for all pins on the related port.
    */
   static __attribute__((always_inline)) void setPinCallback(PinCallbackFunction callback) {
      FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();
      static_assert(Pcr::HANDLER_INSTALLED, "Gpio associated with FTM channel not configured for PIN interrupts - Modify Configure.usbdm");
      Pcr::setPinCallback(callback);
   }
       
#if defined(PORT_PCR_ODE_MASK) and defined (PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
      // Enable output pin in FTM
      ftm->SC = ftm->SC | (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }
#elif defined(PORT_PCR_ODE_ASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue) {

      FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
      // Enable output pin in FTM
      ftm->SC = ftm->SC | (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode);
   }
#elif defined(PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
      // Enable output pin in FTM
      ftm->SC = ftm->SC | (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinSlewRate);
   }
#else
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue) {

      FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
      // Enable output pin in FTM
      ftm->SC = ftm->SC | (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif

      Pcr::setPCR(pinDriveStrength);
   }
#endif

      /**
       * @brief
       * Set subset of Pin Control Register Attributes associated with input direction \n
       * Mux value is set appropriately for the pin function being used. Other attributes are cleared.\n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
       * @param[in] pinAction        One of PinAction_None, etc
       * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive
       *
       *  @note see also configureDigitalFilter(), enableDigitalFilter(), disableDigitalFilter()
       */
      static void setInput(
            PinPull           pinPull           = Pcr::defaultPcrValue,
            PinAction         pinAction         = Pcr::defaultPcrValue,
            PinFilter         pinFilter         = Pcr::defaultPcrValue) {

         FtmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();
//         FtmBase::CheckChannelExistsAndMapped<Info, channel>::check(); // More noisy errors

#ifdef FTM_SC_PWMEN0_SHIFT
         // Disable output pin in FTM
         ftm->SC = ftm->SC & ~(1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif

         Pcr::setInput(pinPull,pinAction,pinFilter);
      }

   };

   /**
    * Default configuration using settings from Configure.usbdmProject
    */
   static void defaultConfigure() {

     configure(Info::DefaultInitValue);

     ftm->EXTTRIG = Info::exttrig;
     ftm->CONF    = FTM_CONF_BDMMODE(1);
     ftm->COMBINE = FTM_COMBINE_FAULTEN0_MASK|FTM_COMBINE_FAULTEN1_MASK|FTM_COMBINE_FAULTEN2_MASK|FTM_COMBINE_FAULTEN3_MASK;

     NVIC_SetPriority(Info::irqNums[0], Info::irqLevel);
   }

};

#ifdef FTM_QDCTRL_QUADEN_MASK

/**
 * Template class representing a FTM configured as a Quadrature decoder
 *
 * @tparam info      Information class for FTM
 *
 * @code
 *  using FtmQuadDecoder = FtmQuadDecoder_T<Ftm0Info>;
 *
 *  // Enable decoder
 *  FtmQuadDecoder::configure();
 *
 *  // Set pin filters
 *  FtmQuadDecoder::enableFilter(15);
 *
 *  // Reset position to zero
 *  // Movement will be +/- relative to this initial position
 *  FtmQuadDecoder::resetPosition();
 *
 *  for(;;) {
 *     console.write("Position =").writeln(QuadDecoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class FtmQuadDecoder_T : protected FtmBase_T<Info> {

private:
   FtmQuadDecoder_T(const FtmQuadDecoder_T&) = delete;
   FtmQuadDecoder_T(FtmQuadDecoder_T&&) = delete;

   FtmBase::CheckChannel<typename Info::InfoQUAD, 0> checkQ0;
   FtmBase::CheckChannel<typename Info::InfoQUAD, 1> checkQ1;

public:
   // Default constructor
   FtmQuadDecoder_T() = default;

   /**
    * Set common fault and Timer Overflow Callback function\n
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   void setCallback(typename Info::CallbackFunction theCallback) {
      FtmBase_T<Info>::setCallback(theCallback);
   }

   using QuadInit = typename Info::QuadInit;

   static constexpr QuadInit DefaultInitValue = Info::DefaultQuadInitValue;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<FTMQUAD_Type> ftm = Info::baseAddress;

   /** Allow more convenient access associated Ftm */
   using OwningFtm = FtmBase_T<Info>;

   /** Allow access to PCR of associated phase-A pin */
   using Pcr0 = PcrTable_T<typename Info::InfoQUAD, 0>;

   /** Allow access to PCR of associated phase-B pin */
   using Pcr1 = PcrTable_T<typename Info::InfoQUAD, 1>;

   /**
    * Set Pin Control Register (PCR) values for PHA and PHB inputs.
    * This will map the pin to the Quadrature function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = Pcr0::defaultPcrValue,
         PinAction         pinAction         = Pcr0::defaultPcrValue,
         PinFilter         pinFilter         = Pcr0::defaultPcrValue) {

      Pcr0::setPCR(pinPull|pinAction|pinFilter);
      Pcr1::setPCR(pinPull|pinAction|pinFilter);
   }

   /**
    * Set polarity of Quadrature inputs.
    *
    * @param polarity Polarity of the two inputs
    */
   static void setPolarity(Polarity polarity) {
      if (polarity == ActiveHigh) {
         ftm->QDCTRL = ftm->QDCTRL & ~(FTM_QDCTRL_PHAPOL_MASK|FTM_QDCTRL_PHBPOL_MASK);
      }
      else {
         ftm->QDCTRL = ftm->QDCTRL | (FTM_QDCTRL_PHAPOL_MASK|FTM_QDCTRL_PHBPOL_MASK);
      }
   }

   /**
    * Set Quadrature mode
    *
    * @param quadratureMode   Mode of operation for the decoder
    */
   static void setMode(FtmQuadratureMode quadratureMode = FtmQuadratureMode_Phase_AB_Mode) {
      if (quadratureMode) {
         ftm->QDCTRL = ftm->QDCTRL | FTM_QDCTRL_QUADMODE_MASK;
      }
      else {
         ftm->QDCTRL = ftm->QDCTRL & ~FTM_QDCTRL_QUADMODE_MASK;
      }
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the FTM
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setTimerOverflowCallback(typename Info::CallbackFunction theCallback) {
      OwningFtm::setTimerOverflowCallback(theCallback);
   }

   /**
    * Enable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void enableTimerOverflowInterrupts() {
      OwningFtm::enableTimerOverflowInterrupts();
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void disableTimerOverflowInterrupts() {
      OwningFtm::disableTimerOverflowInterrupts();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void configureAllPins() {
      // Configure pins
      Info::InfoQUAD::initPCRs();
   }

   /**
    * Disabled all mapped pins associated with FTM
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    */
   static void disableAllPins() {
      // Configure pins
      Info::InfoQUAD::clearPCRs();
   }

   /**
    * Basic enable of FTM
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      // Enable clock to peripheral
      Info::enableClock();

      if constexpr (Info::mapPinsOnEnable) {
         configureAllPins();
      }
   }

   /**
    * Disables the clock to FTM and all mappable pins
    */
   static void disable() {

      disableNvicInterrupts();

      if constexpr (Info::mapPinsOnEnable) {
         disableAllPins();
      }

      // Disable FTM (clock source disabled)
      ftm->QDCTRL = 0;

      // Disable clock to peripheral interface
      Info::disableClock();
   }

   /**
    * Configure QuadDecoder from values specified in init
   
    * @param quadInit Class containing initialisation values
    */
   static ErrorCode configure(const typename Info::QuadInit &quadInit) {
   
      // Assertions placed here so only checked if FtmQuadDecoder actually used
      static_assert(Info::InfoQUAD::info[0].gpioBit >= 0, "FtmQuadDecoder PHA is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Info::InfoQUAD::info[1].gpioBit >= 0, "FtmQuadDecoder PHB is not mapped to a pin - Modify Configure.usbdm");
   
      // Enable peripheral clock and map pins
      enable();
   
      if constexpr (Info::irqHandlerInstalled) {
         // Only set call-back if feature enabled and non-null
         if (quadInit.callbackFunction != nullptr) {
            FtmBase_T<Info>::setCallback(quadInit.callbackFunction);
         }
         enableNvicInterrupts(quadInit.irqlevel);
      }
   
      // Disable timer to change clock (unable to switch directly between clock sources)
      ftm->SC  = 0;
   
      // Start value for counter
      ftm->CNTIN = 0;
   
      // End value for counter
      ftm->MOD =0;
   
      // Restart counter
      ftm->CNT = 0;
   
      // Configure timer
      ftm->FILTER = quadInit.qdfilter;
      ftm->SC     = quadInit.sc;
      ftm->QDCTRL = quadInit.qdctrl;
   
      return E_NO_ERROR;
   }



   /**
    * Basic configuration of Quadrature decoder.
    * Includes configuring all pins if
    * mapPinsOnEnable setting is true
    *
    * @param ftmPrescale       Prescale value applied to the output of the quadrature decode before the counter.
    * @param ftmQuadratureMode Selects the encoding mode used to decode the input changes.
    */
   static void configure(
         FtmPrescale       ftmPrescale       = FtmPrescale_DivBy1,
         FtmQuadratureMode ftmQuadratureMode = FtmQuadratureMode_Phase_AB_Mode
         ) {
      // Assertions placed here so only checked if FtmQuadDecoder actually used
      static_assert(Info::InfoQUAD::info[0].gpioBit >= 0, "FtmQuadDecoder PHA is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Info::InfoQUAD::info[1].gpioBit >= 0, "FtmQuadDecoder PHB is not mapped to a pin - Modify Configure.usbdm");

      enable();

      // Disable so immediate effect
      ftm->SC = 0;
      (void)ftm->SC;
      ftm->SC = FtmClockSource_Disabled|ftmPrescale;

      ftm->QDCTRL =
            FTM_QDCTRL_QUADEN_MASK|      // Enable Quadrature decoder
            ftmQuadratureMode;           // Quadrature mode
      ftm->CONF   = FTM_CONF_BDMMODE(3);
   }

   /**
    * Enable/disables filtering of quadrature inputs
    *
    * @param[in] filterValue 0=>disable, 1..15 filter length
    */
   static void enableFilter(int filterValue=7) {
      if (filterValue>0) {
         ftm->FILTER = ftm->FILTER | FTM_FILTER_CH0FVAL(filterValue)| FTM_FILTER_CH1FVAL(filterValue);
         ftm->QDCTRL = ftm->QDCTRL | FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK;
      }
      else {
         ftm->QDCTRL = ftm->QDCTRL & ~(FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK);
      }
   }

   /**
    * Reset position to zero
    */
   static void resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      ftm->CNT = 0;
   }

   /**
    * Get Quadrature decoder position
    *
    * @return Signed number representing position relative to reference location
    *
    * @note This can be viewed as a signed number +/- relative to the initial position.
    * @note This can be viewed as an unsigned number counting up from 0
    *       with overflow at 0xFFFF and underflow at 0.
    */
   static int16_t getPosition() {
      return (int16_t)(ftm->CNT);
   }

   /**
    * Get Quadrature decoder overflow direction.
    * This would be used in the overflow callback.
    *
    * @return Timer overflow direction. true => increasing, false => decreasing.
    *
    * @note Overflow occurs at MOD -> CNTIN, Underflow occurs at CNTIN -> MOD.
    */
   static bool getOverflowDirection() {
      return (bool)(ftm->QDCTRL & FTM_QDCTRL_TOFDIR_MASK);
   }
};
#endif // defined(FTM_QDCTRL_QUADEN_MASK)

/**
* Class representing FTM0
*/
class Ftm0 : public FtmBase_T<Ftm0Info> {};

/**
* Class representing FTM1
*/
class Ftm1 : public FtmBase_T<Ftm1Info> {};

/**
* Class representing FTM2
*/
class Ftm2 : public FtmBase_T<Ftm2Info> {};

/**
* Class representing FTM3
*/
class Ftm3 : public FtmBase_T<Ftm3Info> {};


   /**
    * Class representing Ftm1 as Quadrature decoder
    */
   typedef FtmQuadDecoder_T<Ftm1Info> FtmQuadDecoder1;
   /**
    * Class representing Ftm2 as Quadrature decoder
    */
   typedef FtmQuadDecoder_T<Ftm2Info> FtmQuadDecoder2;

/**
 * End FTM_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_FTM_H */

